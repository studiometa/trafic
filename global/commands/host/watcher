#!/usr/bin/env bash
#ddev-generated

## Description: Automatically stop and start projects based on their access.
## Usage: watcher [flags] [args]
## Example: ddev watcher start 10m\nddev watcher stop 1h
## Flags: [{"Name":"dry-run","Usage":"Do not perform any action"}]
## AutocompleteTerms: ["start","stop"]
## CanRunGlobally: true

set -o errexit
set -o nounset
set -o pipefail

DDEV_TLD=${DDEV_TLD:-"studiometa.dev"}
ALL_ARGS="$@"
ARGS="$@"
DRY_RUN=false
LOG_LEVEL="info" # debug

if [[ "${ARGS-}" =~ --dry-run ]]
then
    ARGS=${ARGS/--dry-run/}
    DRY_RUN=true
fi

if [[ "${ARGS-}" =~ --debug ]]
then
    ARGS=${ARGS/--debug/}
    LOG_LEVEL="debug"
fi

if [[ "${ARGS-}" =~ --trace ]]
then
    ARGS=${ARGS/--trace/}
    set -o xtrace
fi


if [[ "${1-}" =~ ^-*h(elp)?$ ]]; then
    echo 'Usage: ddev watcher <COMMAND> [TIMESTAMP]

Automatically stop and start ddev projects based on their access.
The default duration are 4 hours for the `stop` command and 1 minute for
the `start` command.

The state of a project is defined by reading the logs of the `ddev-router`
container with the `--since` parameter of the `docker logs` command. The logs
are parsed with `jq`, so they must be configured to be in JSON format.

Examples:

  # Start projects that have been visited in the last 10 minutes
  ddev watcher start 10m

  # Stop all projects not visited since 1 hour
  ddev watcher stop 1h
'
    exit
fi

log() {
    echo "[$(date +"%Y/%m/%d %H:%M:%S")] $@"
}

stop() {
    SINCE=${1:-'12h'}
    log "Stopping projects not accessed since $SINCE..."

    RUNNING_PROJECTS=$(ddev ls -j 2>/dev/null | jq -r '.raw[] | select(.status != "stopped") | .name')
    RUNNING_PROJECTS_COUNT=$(echo "$RUNNING_PROJECTS" | wc -l)
    ACCESSED_PROJECTS=$(docker logs ddev-router --since $SINCE 2> /dev/null | grep -E '^{' | jq -r 'select(.RouterName != "ping@internal" and .ServiceAddr != null) | .ServiceAddr' | sort | uniq | sed -E 's/ddev-(.*)-web:80/\1/')

    if [[ $RUNNING_PROJECTS_COUNT -le 1 ]]
    then
        log "Only one project running, doing nothing."
        exit
    fi

    PROJECTS_TO_STOP=""

    for RUNNING_PROJECT in $(echo $RUNNING_PROJECTS)
    do
        if [[ ! $(echo $ACCESSED_PROJECTS | grep "$RUNNING_PROJECT") ]]
        then
            PROJECTS_TO_STOP+=$'\n'"$RUNNING_PROJECT"
        else
            log "→ $RUNNING_PROJECT is visited, doing nothing."
        fi
    done

    # Remove first empty line
    PROJECTS_TO_STOP="$(echo "$PROJECTS_TO_STOP" | sed 1d)"
    PROJECTS_TO_STOP_COUNT=$(echo "$PROJECTS_TO_STOP" | wc -l)

    if [[ $PROJECTS_TO_STOP_COUNT == $RUNNING_PROJECTS_COUNT ]]
    then
        log "Omitting $(echo "$PROJECTS_TO_STOP" | head -n 1) to keep one project running."
        PROJECTS_TO_STOP="$(echo "$PROJECTS_TO_STOP" | sed 1d)"
    fi

    for PROJECT in $(echo $PROJECTS_TO_STOP)
    do
        log "↓ $PROJECT has not been accessed since $SINCE, shutting down..."
        # ! $DRY_RUN && ddev export-db $PROJECT --file="$HOME/backup/$PROJECT.sql.gz"
        ! $DRY_RUN && ddev stop $PROJECT
    done
}

start() {
    SINCE=${1:-'1m'}

    STOPPED_PROJECTS=$(ddev ls -j 2>/dev/null | jq -r '.raw[] | select(.status == "stopped") | .name')
    UNMATCHED_PROJECTS=$(docker logs ddev-router --since $SINCE 2> /dev/null | grep -E '^{' | jq -r 'select(.RouterName != "ping@internal" and .ServiceAddr == "custom-error-pages:80" and .RequestHost != null) | .RequestHost' | sort | uniq | sed -E "s/(.*).$DDEV_TLD/\1/")

    PROJECTS_TO_START=""
    for STOPPED_PROJECT in $(echo $STOPPED_PROJECTS)
    do
        if [[ $(echo $UNMATCHED_PROJECTS | grep "$STOPPED_PROJECT") ]]
        then
            log "↑ $STOPPED_PROJECT is being accessed, starting up..."
            PROJECTS_TO_START="$PROJECTS_TO_START $STOPPED_PROJECT"
        else
            log "✕ $STOPPED_PROJECT is stopped and not being accessed, doing nothing."
        fi
    done

    if [[ $(echo $PROJECTS_TO_START | xargs) ]]
    then
        log "Starting the following projects:$PROJECTS_TO_START"
    if [[ ! $DRY_RUN ]]
    then
        ddev start $PROJECTS_TO_START
    fi
    fi
}

main() {
    $DRY_RUN && log "This is a dry run, nothing will happen."

    CMD=${1:-}
    SINCE=${2:-}

    if [[ -z $CMD ]]
    then
    log "One of the 'start' or 'stop' subcommand is required."
    exit
    fi

    if [[ $CMD == "stop" ]]
    then
        stop "$SINCE"
    fi

    if [[ $CMD == "start" ]]
    then
        start "$SINCE"
    fi
}

log "> ddev watcher $@"
main $ARGS

